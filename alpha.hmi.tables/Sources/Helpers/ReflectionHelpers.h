#pragma once


#include "mixin.h"

namespace Alpha
{
	namespace Hmi
	{
		namespace Tables
		{
			namespace Reflection
			{

				////////////////////////////////////////////////////////////////////////////////
				///	@short
				///		Класс для рефлексии базы графических объектов
				///
				///	@details
				///			Данный класс предоставляет общие для всех графических объектов
				///		методы для экспорта через рефлексию (интерфейс HMIFeatures::IBase).
				///		Этот класс содержит набор геттеров и сеттеров для организации набора
				///		свойств (properties) у экспортированного объекта объектной модели Om.
				////////////////////////////////////////////////////////////////////////////////
				template <typename Implementation>   // имплементэйшн - реализация
				class reflected_visual
					:	public mixin<Implementation>
				{
				public:

					reflected_visual()
					{
					}

					////////////////////////////////////////////////////////////////////////////////
					///	@short
					///		Геттер координаты X
					////////////////////////////////////////////////////////////////////////////////
					double GetX() const
					{
						return to_const_impl(this)->pos().x();
					}

					////////////////////////////////////////////////////////////////////////////////
					///	@short
					///		Сеттер координаты X
					////////////////////////////////////////////////////////////////////////////////
					void SetX(double x)
					{
						auto pos = to_impl(this)->pos();
						pos.setX(x);
						to_impl(this)->setPos(pos);
					}

					////////////////////////////////////////////////////////////////////////////////
					///	@short
					///		Геттер координаты Y
					////////////////////////////////////////////////////////////////////////////////
					double GetY() const
					{
						return to_const_impl(this)->pos().y();
					}

					////////////////////////////////////////////////////////////////////////////////
					///	@short
					///		Сеттер координаты Y
					////////////////////////////////////////////////////////////////////////////////
					void SetY(double y)
					{
						auto pos = to_impl(this)->pos();
						pos.setY(y);
						to_impl(this)->setPos(pos);
					}

					////////////////////////////////////////////////////////////////////////////////
					///	@short
					///		Геттер угла поворота
					////////////////////////////////////////////////////////////////////////////////
					double GetRotation() const
					{
						return to_const_impl(this)->rotation();
					}

					////////////////////////////////////////////////////////////////////////////////
					///	@short
					///		Сеттер угла поворота
					////////////////////////////////////////////////////////////////////////////////
					void SetRotation(double rotation)
					{
						to_impl(this)->setRotation(rotation);
					}

					////////////////////////////////////////////////////////////////////////////////
					///	@short
					///		Получить масштаб элемента
					////////////////////////////////////////////////////////////////////////////////
					double GetScale() const
					{
						return to_const_impl(this)->scale();
					}

					////////////////////////////////////////////////////////////////////////////////
					///	@short
					///		Установить масштаб элемента
					////////////////////////////////////////////////////////////////////////////////
					void SetScale(double scale)
					{
						to_impl(this)->setScale(scale);
					}

					////////////////////////////////////////////////////////////////////////////////
					///	@short
					///		Геттер видимости объекта
					////////////////////////////////////////////////////////////////////////////////
					bool GetVisible() const
					{
						return to_const_impl(this)->isVisible();
					}

					////////////////////////////////////////////////////////////////////////////////
					///	@short
					///		Сеттер видимости объекта
					////////////////////////////////////////////////////////////////////////////////
					void SetVisible(bool visible)
					{
						to_impl(this)->setVisible(visible);
					}

					////////////////////////////////////////////////////////////////////////////////
					///	@short
					///		Получить признак включенности
					////////////////////////////////////////////////////////////////////////////////
					bool GetEnabled() const
					{
						return to_const_impl(this)->isEnabled();
					}

					////////////////////////////////////////////////////////////////////////////////
					///	@short
					///		Установить признак включенности
					////////////////////////////////////////////////////////////////////////////////
					void SetEnabled(bool enable)
					{
						to_impl(this)->setEnabled(enable);
					}

					////////////////////////////////////////////////////////////////////////////////
					///	@short
					///		Получить текст высплывающей подсказки
					////////////////////////////////////////////////////////////////////////////////
					Alpha::Binbo::default_string GetTooltip() const
					{
						return to_const_impl(this)->toolTip().toUtf8().data();
					}

					////////////////////////////////////////////////////////////////////////////////
					///	@short
					///		Установить текст высплывающей подсказки
					////////////////////////////////////////////////////////////////////////////////
					void SetTooltip(Alpha::Binbo::default_string const &tooltip)
					{
						to_impl(this)->setToolTip(QString::fromStdString(tooltip));
					}

				};	//reflected_visual


				////////////////////////////////////////////////////////////////////////////////
				///	@short
				///		Класс для рефлексии прямоугольных графических объектов
				///
				///	@details
				///			Данный класс предоставляет рефлексию графических объектов,
				///		поддерживающих интерфейс HMIFeatures::IRect.
				////////////////////////////////////////////////////////////////////////////////
				template <typename Implementation>
				class reflected_rect
					:	public mixin<Implementation>
				{
				public:

					////////////////////////////////////////////////////////////////////////////////
					///	@short
					///		Геттер ширины прямоугольника
					/// @returns
					///		Значение ширины прямоугольника
					///	@details
					///		Метод возвращает значение ширины прямоугольника.
					////////////////////////////////////////////////////////////////////////////////
					double GetWidth() const
					{
						return to_const_impl(this)->rect().size().width();
					}

					////////////////////////////////////////////////////////////////////////////////
					///	@short
					///		Сеттер ширины прямоугольника
					///	@param [in] width
					///		Новое значение ширины прямоугольника
					///	@details
					///		Метод устанавливает новое значение ширины прямоугольника.
					////////////////////////////////////////////////////////////////////////////////
					void SetWidth(double width)
					{
						auto rect = to_impl(this)->rect();
						rect.setWidth(width);
						to_impl(this)->setRect(rect);
					}

					////////////////////////////////////////////////////////////////////////////////
					///	@short
					///		Геттер высоты прямоугольника
					/// @returns
					///		Значение высоты прямоугольника
					///	@details
					///		Метод возвращает значение высоты прямоугольника.
					////////////////////////////////////////////////////////////////////////////////
					double GetHeight() const
					{
						return to_const_impl(this)->rect().size().height();
					}

					////////////////////////////////////////////////////////////////////////////////
					///	@short
					///		Сеттер высоты прямоугольника
					///	@param [in] height
					///		Новое значение высоты прямоугольника
					///	@details
					///		Метод устанавливает новое значение высоты прямоугольника.
					////////////////////////////////////////////////////////////////////////////////
					void SetHeight(double height)
					{
						auto rect = to_impl(this)->rect();
						rect.setHeight(height);
						to_impl(this)->setRect(rect);
					}

				};	//reflected_rect

			}	//namespace Reflection
		}	//namespace Tables
	}	//namespace Hmi
}	//namespace Alpha
